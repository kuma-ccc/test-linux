# ====================================================================
# 1. 变量定义区
# ====================================================================

# 目标文件名
TARGET = testepoll

# 源文件列表
# 假设您的主文件名为 epoll.cpp
SRCS = epoll.cpp 

# 编译器选择：使用交叉编译器的 C++ 版本
# 如果您的工具链中只有 arm-linux-gnueabihf-gcc，也可以将其替换，但通常推荐使用 g++
CXX = arm-linux-gnueabihf-g++ 

# 编译器标志 (Compiler Flags)
# -Wall: 开启所有常用警告
# -g: 包含调试信息，方便使用 gdb 调试
# -O2: 优化级别 2 (中等优化)
# -std=c++17: 显式指定使用 C++17 标准 (解决了您之前遇到的 C++11 兼容性问题)
CXXFLAGS = -Wall -g -O2 -std=c++11

# 链接器标志 (Linker Flags)
# -lstdc++: 显式链接 C++ 标准库 (对于交叉编译环境有时是必需的)
# -lpthread: 如果使用了多线程，需要链接线程库
LDFLAGS = -lstdc++ -lpthread 

# ====================================================================
# 2. 规则定义区
# ====================================================================

# 默认目标 (Default Goal)：当只输入 make 时执行
.PHONY: all
all: $(TARGET)

# 主目标规则：如何从对象文件生成最终可执行文件
# 依赖：$(OBJS)
$(TARGET): $(SRCS:.cpp=.o)
	@echo "Linking $(TARGET)..."
	$(CXX) $(SRCS:.cpp=.o) -o $@ $(LDFLAGS)

# 编译规则 (将 .cpp 文件编译成 .o 对象文件)
# %: 匹配任意字符
# $^: 代表所有依赖文件 (此处为 .cpp 文件)
# $@: 代表目标文件 (此处为 .o 文件)
%.o: %.cpp
	@echo "Compiling $<..."
	$(CXX) $(CXXFLAGS) -c $< -o $@

# --------------------------------------------------------------------
# 3. 清理目标 (Cleanup Goal)
# --------------------------------------------------------------------

.PHONY: clean
clean:
	@echo "Cleaning up..."
	# 删除生成的目标文件和所有对象文件
	rm -f $(TARGET) $(SRCS:.cpp=.o)

# --------------------------------------------------------------------
# 4. 依赖自动生成（可选，但推荐用于复杂项目）
# --------------------------------------------------------------------
# 如果您的项目包含多个头文件，可以启用此功能自动生成依赖关系，
# 确保头文件修改后，对应的源文件也会被重新编译。

# .depend:
# 	$(CXX) -MM $(CXXFLAGS) $(SRCS) > .depend
# 
# include .depend
